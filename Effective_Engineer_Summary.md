## Focus on High-Leverage Activities

* **Use Leverage as your Yardstick for Effectiveness**
	* Define Leverage: Impact produced / Time invested

* **Increase Your leverage in three ways:**
	* By reducing the time it takes to complete a certain activity
	* By increasing the output of a particular activity
	* By shifting to higher-leverage activities 
	(see page 15 for two examples how this framework can be used)

* **Direct Energy Toward Leverage Points, Not Just Easy Wins**
	* Identify the habits that produce disproportionately high impact for the time you invest
	* Don’t confuse high-leverage activities with easy wins, high leverage activities can be consistent hardwork

## Optimize for Learning

* **Adopt a Growth Mindset**
	* Adopt Growth Mindset rather than fixed mindset
	* Own your story

* **Invest in your rate of learning**
	* Learning follows an exponential growth curve. Knowledge begets Knowledge
	* The earlier that you optimize for learning, the more time your learning has to compound
	* Due to compounding, even small deltas in your own learning rate make a big difference over the long run (Google example, Palantir co-founder Stephen Cohen)

* **Seek Work Environments Conducive to Learning**
	* Fast Growth: join the rocketship 
	* Training: onboarding, mentorship, continuous learning through EDU
	* Openness: Challenge each others’ decisions and incorporate feedback into the future iterations
	* Pace: iterates quickly provides a faster feedback cycle and enables you to learn at a faster rate
	* People: Surrounding yourself with people who are smarter, more talented, and more creative than you
	* Autonomy: The freedom to choose what to work on and how to do it drives our ability to learn
	(Be sure to check out the list of questions for each of these areas Edmond outline)

* **Dedicate Time on the Job to Develop New Skills**
	* Study code for core abstractions written by the best engineers at your company
	* Write more code
	* Go through any technical, educational material available internally
	* Master the programming languages that you use
	* Send your code reviews to the harshest critics
	* Enroll in classes on areas where you want to improve
	* Participate in design discussions of projects you’re interested in
	* Work on a diversity of projects
	* Make sure you’re on a team with at least a few senior engineers whom you can learn from
	* Jump fearlessly into code you don’t know

* **Always be learning, even outside of work**
	* Learn new programming languages and frameworks
	* Invest in skills that are in high demand
	* Read books
	* Join a discussion group
	* Attend talks, conferences, and meetups
	* Build and maintain a strong network of relationships
	* Follow bloggers who teach
	* Write to teach
	* Tinker on side projects
	* Pursue what you love

## Prioritize Regularly

* **Track To-Dos in a Single, Easily Accessible List**
	* To-do lists should have two major properties: 
		* they should be a canonical representation of our work
		* they should be easily accessible
	* The goal isn’t to establish a total ordering of all your priorities, since any ordering you make will be based on imperfect information; instead, continuously shift your top priorities toward the ones with the highest leverage, given the information you have
	(Spent your time prioritizing, which is a high leverage activity, than using your memory to remember tasks)

* **How to identify high leverage task: 1. Focus on What Directly Produces Value**
	* time and effort expended do not necessarily correlate with the value produced
	* Corollary: to focusing on the activities that directly produce value is to defer and ignore the ones that don’t

* **How to identify high leverage task: 2. Focus on the Important and Non-Urgent**
	* Side aside time for important and non-urgent, as they are high leverage activities
	* If you are constantly fire fighting important and urgent tasks, it might be a symptom of under-investment in important and non-urgent

* **Protect Your Maker’s Schedule**
	* When possible, preserve larger blocks of focused time in your schedule

* **Limit the Amount of Work in Progress**
	* As it increase context switching cost and complexity of communication at a team level

* **Fight Procrastination with If-Then Plans**
	* identify ahead of time a situation where we plan to do a certain task
	* if-then constructs helps to build trigger & behaviors automatically

* **Make a Routine of Prioritization**
	* Revisit your prioritized list and conditions change overtime
	* You need to routinize and come up with a simple system to do this regularly
		* A simple tool to track things
		* Pomodoro's technique
		* Daily planning
		* Wekkly planning
	(You currently don't have a system)


# Second Part of the Book

## Invest in Iteration Speed - Move Fast to Learn Fast

* **Invest in time-saving tools**
	* faster tool gets used more often
	* faster tools can enable new development workflows that previously weren’t possible!
	* The time-saving properties of tools also scale with team adoption -- this is why large companies have dev prod
	* make sure to lower the switching costs for others
	* start small. Find an area where a tool could save time, build it, and demonstrate its value

* **Shorten Your Debugging and Validation Loops**
	* removes all unnecessary distractions so that more time and energy can be spent on the core issue, and it creates a tight feedback loop so that we can iterate quickly
	(This is abstract, so see examples in page 73, 74)
	* When you’re already using a workflow that works, albeit with a few extra steps, it’s easy to get complacent and not expend the mental cycles on devising a shorter one. Don’t fall into this trap!
	* know when to make upfront investments to shorten debugging loops rather than pay a tax on time for every iteration. Short-circuiting is the key!

* **Master Your Programming Environment**
	* The key is to be mindful of which of your common, everyday actions slow you down, and then figure out how to perform those actions more efficiently 
	(See examples in page 76)
	* Get proficient with your favorite text editor or IDE
	* Learn at least one productive, high-level programming language
	* Get familiar with UNIX (or Windows) shell commands
	* Prefer the keyboard over the mouse
	* Automate your manual workflows
	* Test out ideas on an interactive interpreter
	* Make it fast and easy to run just the unit tests associated with your current changes

* **Don’t Ignore Your Non-Engineering Bottlenecks**
	* One common type of bottleneck is dependency on other people. 
		* oftentimes the cause is a misalignment of priorities rather than negative intention. 
		* The sooner you acknowledge that you need to personally address this bottleneck, the more likely you’ll be able to move forward
		* Communication is critical for making progress on people-related bottlenecks
	
	* Another common type of bottleneck is obtaining approval from a key decision maker, typically an executive at the company
		* Focus on securing buy-in as soon as possible
		* Explicitly ask the decision makers what they care about the most, so that you can make sure to get those details right
	
	* A third type of bottleneck is the review processes that accompany any project launch, whether they be verification by the quality assurance team, a scalability or reliability review by the performance team, or an audit by the security team
		* Plan ahead. Expend slightly more effort in coordination
		* Get the ball rolling on the requirements in your launch checklist, and don’t wait until the last minute
	
	* Find out where the biggest bottlenecks in your iteration cycle are, whether they’re in the engineering tools, cross-team dependencies, approvals from decision-makers, or organizational processes. Then, work to optimize them. (Again, it's all about leverage!)


## Measure What You Want to Improve

* **Use Metrics to Drive Progress**
	* They confirm that your product changes and all the effort you’ve put into them actually achieve your objectives
	* when visualized over time, good metrics help guard against future regressions (diagnostics through visualization)
	* Third, good metrics can drive forward progress (fuzzy)
	* Fourth, a good metric lets you measure your effectiveness over time and compare the leverage of what you’re doing against other activities you could be doing instead

* **Pick the Right Metric to Incentivize the Behavior You Want**
	* the choice of which metric to measure dramatically impacts and influences the type of work that we do
	(A lot of nice examples to demonstrate this point on page 88 - 90)
	* What you don’t measure is important as well, as it can avoid certain unwanted behaviors
	* Picking the right metric applies to your personal goals as well as your professional ones (book writing: hours v.s. 1000 words a day)
	* When deciding what metrics to use, chooses ones that
		* maximize impact: when systematically increased over time, leads you and the rest of your team to make the greatest and most sustainable impact
		* actionable: is one whose movements can be causally explained by the team’s efforts. vanity metrics track gross numbers that are hard to explain the real movement behind the change
		* responsive yet robust: updates quickly enough to give feedback about whether a given change was positive or negative, so that your team can learn where to apply future efforts. However, a metric also needs to be robust enough that external factors outside of the team’s control don’t lead to significant noise

* **Instrument Everything to Understand What’s Going On**
	* When establishing our goals, it’s important to choose carefully what core metrics to measure (or not measure) and optimize. When it comes to day-to-day operations, however, you should be less discriminatory: measure and instrument as much as possible. Although these two principles may seem contradictory, they actually complement each other. The first describes a high-level, big picture activity, whereas the second is about gaining insight into what’s going on with systems that we’ve built
	(examples at page 95)
	* Adopting a mindset of instrumentation means ensuring we have a set of dashboards that surface key health metrics and that enable us to drill down to the relevant data. However, many of the questions we want to answer tend to be exploratory, since we often don’t know everything that we want to measure ahead of time. Therefore, we need to build flexible tools and abstractions that make it easy to track additional metrics

* **Internalize Useful Numbers**
	* The knowledge of useful numbers or baselines provides a valuable shortcut for knowing where to invest effort to maximize gains
	* Oftentimes, you don’t need accurate numbers to make effective decisions; you just need ones that are in the right ballpark. Ensuring you have access to a few useful numbers to approximate your progress and benchmark your performance is a high-leverage investment with low cost
		* For engineering, this can drive technical design
		* Internalizing useful numbers can also help you spot anomalies in data measurements
		* knowledge of useful numbers can clarify both the areas and scope for improvement
		* help you to build more intuition about where to direct effort to maximize your leverage

* **Be Skeptical about Data Integrity**
	* Good math students get to the end of the problem, look at their answer, and say, ‘Does that roughly make sense?’” When it comes to metrics, compare the numbers with your intuition to see if they align
	* Try to arrive at the same data from a different direction and see if the metrics still make sense
	* If a metric implies some other property, try to measure the other property to make sure the conclusions are consistent
	* Untrustworthy data that gets incorporated into decision-making processes provides negative leverage - It may lead teams to make the wrong decision or waste cognitive cycles second-guessing themselves
	* metrics-related code tends to be less robust than code for other features (see page 103 why this is the case)
	* investing the effort to ensure that your data is accurate is high-leverage
		* Log data liberally, in case it turns out to be useful later on
		* Build toolsto iterate on data accuracy sooner
		* Write end-to-end integration tests to validate your entire analytics pipeline
		* Examine collected data sooner
		* Cross-validate data accuracy by computing the same metric in multiple ways
		* When a number does look off, dig in to it early

## Validate Your Ideas Early and Often

* **Find Low-Effort Ways to Validate Your Work**
	* the sooner that we gain a better understanding of a risky issue that impedes our progress, the earlier we can either address it to increase our chances of success, or change course to a more promising avenue
	* expend a small fraction of the total effort to collect some data and validate that what you are doing will work
	* The strategy of faking the full implementation of an idea to validate whether it will work is extremely powerful
	(Dropbox, MySQL migration, code rewrites, 42Floors...etc, do things that don't scale is ok)
	* invest a small amount of work to gather data to validate your project assumptions and goals. In the long run, you’ll save yourself a lot of wasted effort.
	
* **Continuously Validate Product Changes with A/B Testing**
	* A/B testing removes confounding, and quantify how much metrics have moved as a result of the change
	* A/B tests also encourage an iterative approach to product development
	* When deciding what to A/B test, time is your limiting resource. Hone into differences that are high-leverage and practically significant

* **Beware the One-Person Team (Qualitative)**
	* a common anti-pattern to watch out for is the one-person team
		* First and foremost, it adds friction to the process of getting feedback
		* The lows of a project are more demoralizing when you’re working alone
		* Similarly, the highs can be less motivating when you’re working alone
	
	* Some strategies to avoid the pitfalls of one person team:
		* Be open and receptive to feedback
		* Commit code early and often
		* Request code reviews from thorough critics
		* Ask to bounce ideas off your teammates
		* Design the interface or API of a new system first
		* Send out a design document before devoting your energy to your code
		* If possible, structure ongoing projects so that there is some shared context with your teammates
		* Solicit buy-in for controversial features before investing too much time

* **Build Feedback Loops for Your Decisions**
	* the principle of validation generalizes to any decision you make. The principle of validation shows us that many of our work decisions, which we might take for granted or adopt blindly from other people, in fact are testable hypotheses
	* Validation means formulating a hypothesis about what might work, designing an experiment to test it, understanding what good and bad outcomes look like, running the experiment, and learning from the results

## Improve Your Project Estimation Skills

* **Use Accurate Estimates to Drive Project Planning**
	* Engineers create estimates (best guess of how long or how much work), and managers and business leaders specify targets (desire business goal). How to effectively handle gaps between the estimates and targets is the focus of this chapter. 
	* A more productive approach is to use the estimates to inform project planning, rather than the other way around
	* How can we estimate better:
		* Decompose the project into granular tasks
		* Estimate based on how long tasks will take, not on how long you or someone else wants them to take
		* Think of estimates as probability distributions, not best-case scenarios
		* Let the person doing the actual task make the estimate
		* Beware of anchoring bias
		* Use multiple approaches to estimate the same task
		* Beware the mythical man-month: adding new team members create communication overhead
		* Validate estimates against historical data
		* Use timeboxing to constrain tasks that can grow in scope
		* Allow others to challenge estimates
	* Measuring the actual time it takes to perform a task and comparing it against the estimated time helps reduce the error bounds
	* Revising estimate early and often through validation
	* Estimation is a skill that can be learned and you will get better over time. Project estimation and project planning are extremely difficult to get right, and many engineers (myself included) have learned this the hard way. The only way to get better is by practicing these concepts, especially on smaller projects where the cost of poor estimations is lower

* **Budget for the Unknown**
	* We can better deal with unknowns by acknowledging that the longer a project is, the more likely that an unexpected problem will arise
	* The first step in dealing with this is to separate estimated work time from calendar time
		* "this project will take one month of engineering work to complete” != “this project will be completed in one calendar month”. 
		* Our estimates more naturally revolve around the time required to complete work, but managers, customers, and marketers think in terms of delivery dates
	* When setting schedules, build in buffer time for the unexpected interruptions
		* One-off interruptions happen all the time
		* The effect of these interruptions is further compounded when schedules slip, because you need to recommit to other efforts

* **Define Specific Project Goals and Measurable Milestones**
	* a well-defined goal provides an important filter for separating the musthaves from the nice-to-haves in the task list
	* The second benefit of defining specific project goals is that it builds clarity and alignment across key stakeholders
	* Building alignment also helps team members be more accountable for local tradeoffs that might hurt global goals
	* A concrete milestone, with a specified set of features X, Y, and Z and preferably accompanied by a target completion date, keeps us honest and lets us more accurately measure whether we’re on track or far behind
	* Milestones act as checkpoints for evaluating the progress of a project and as channels for communicating the team’s progress to the rest of the organization (racetrack analogy)

* **Reduce Risk Early**
	* Tackling the riskiest areas first helps us identify any estimation errors associated with them
	* Don’t give yourself the illusion of progress by focusing first on what’s easy to do

* **Approach Rewrite Projects with Extreme Caution, they are hard because**
	* They share the same project planning and estimation difficulties as other software projects
	* we tend to be familiar with the original version, which cause over-confidence
	* It is easy and tempting to bundle additional improvements into a rewrite
	* When a rewrite is ongoing, any new features or improvements must either be added to the rewritten version or duplicated across existing

* **Don’t Sprint in the Middle of a Marathon**
	* why working more hours doesn’t necessarily mean hitting the launch date:
		* Hourly productivity decreases with additional hours worked
		* You’re probably more behind schedule than you think
		* Additional hours can burn out team members
		* Working extra hours can hurt team dynamics
		* Communication overhead increases as the deadline looms
		* The sprint toward the deadline incentivizes technical debt
	
	* In case there is no other choice but to work overtime:
		* Making sure everyone understands the primary causes for why the timeline has slipped thus far 
		* Developing a realistic and revised version of the project plan and timeline
		* Being ready to abandon the sprint if you slip even further from the revised timeline

## Balance Quality with Pragmatism (More specific to software engineering)

* **Establish a Sustainable Code Review Process**
	* Catching bugs or design shortcomings early
	* Increasing accountability for code changes
	* Positive modeling of how to write good code
	* Sharing working knowledge of the codebase
	* Increasing long-term agility

	(There is a trade-off in doing code reivew: it slows down development speed in the short term, but it also help all the areas mentioned above. The decision of code review should not be treated as a binary one, but in a continuium. See page 159 for a list of examples)

* **Manage Complexity through Abstraction**
	* It reduces the complexity of the original problem into easier-to-under- stand primitives
	* It reduces future application maintenance and makes it easier to apply future improvements
	* It solves the hard problems once and enables the solutions to be used multiple times
	(Trade-offs again: make sure the time saved by the abstraction for future engineers outwigh the time invested for developing it in the first place)

* **Automate Testing**
	* It reduces bugs
	* It decreases repetitive work that we’d otherwise need to do by hand, rather than triggering different code branches, we can programmatically test them
	* Tests also allow engineers to make changes, especially large refactorings, with significantly higher confidence
	* When code does break, automated tests help to efficiently identify who’s accountable
	* tests offer executable documentation of what cases the original au- thor considered and how to invoke the code
	(Writing tests again has trade-offs: the key is to demonstrate its value as a start, people will follow)

* **Repay Technical Debt**
	(Sometimes, we build things in a way that makes sense in the short-term but that can be costly in the long-term)
	* The key to being a more effective engineer is to incur technical debt when it’s necessary to get things done for a deadline, but to pay off that debt periodically
	* Not all tech debts are worth repaying - The more fre- quently a part of the codebase is read, invoked, and modified, the higher the interest payments for any technical debt in that code

## Minimize Operational Burden
(The recurring costs of operating a system or product require time and energy that could be spent on higher-leverage activities. Shaving time off of recurring costs frees you to fo- cus on what matters most)

*  **Embrace Operational Simplicity**
	(Effective engineers focus on simplicity. Simple solutions impose a lower oper- ational burden because they’re easier to understand, maintain, and modify). Complexity leads to:
	* Engineering expertise gets splintered across multiple systems
	* Increased complexity introduces more potential single points of failure
	* New engineers face a steeper learning curve when learning and under- standing the new systems
	* Effort towards improving abstractions, libraries, and tools gets diluted across the different systems

* **Build Systems to Fail Fast**
	* Slowly failing systems muddy the sources of code errors, making it difficult for us to discover what went wrong
	* The more directly we can link the feedback to a source, the more quickly that we can reproduce the problem and address the issue 
	* The more complex the system, the more time that fail-fast techniques can save
	* build automated pipelines to aggregate the logged errors and sort them by frequency in a dashboard, so that engineers can address them in order of importance

* **Relentlessly Automate Mechanical Tasks**
	* Applying a quick manual band-aid to address a problem might take less time than building a sustainable fix. But in the long run, automating solutions and script- ing repetitive tasks reduce our operational burden
	* Central question: Will I save more time overall by manually doing a particular task or by paying the upfront cost of automating the process?
	* Reasons why engineers don't automate:
		* They don’t have the time right now
		* They suffer from the tragedy of the commons
		* They lack familiarity with automation tools
		* They underestimate the future frequency of the task
		* They don’t internalize the time savings over a long time horizon
	* Differentiate automating mechanics and automating decision-making
	* Automation can produce diminishing returns as you move from automat- ing mechanics to automating decision-making

* **Make Batch Processes Idempotent**
	* One technique to make batch processes easier to maintain and more resilient to failure is to make them idempotent
	* An idempotent process produces the same results regardless of whether it’s run once or multiple times
	* When idempotence isn’t possible, structuring a batch process so that it’s at least retryable or reentrant - is able to complete successfully after a previous interrupted call.
	* Idempotent process also increase the ability to run infrequent processes at a more frequent rate than strictly necessary, to expose problems sooner
		* A system check that runs every 5 to 10 minutes might raise spurious alarms because a temporary network glitch causes it to fail, but running the check every 60 seconds and only raising an alarm on consecutive failures dramatically decreases the chances of false positives

* **Hone Your Ability to Respond and Recover Quickly**
	* how we handle failures plays a large role in our effectiveness
	* Script for success - write scripts, or contigency plans for how to respond to all types of scenarios.

## Invest in Your Team’s Growth

The people and the team that you work with have a significant impact on your own effectiveness. The higher you climb up the engineering ladder, the more your effective- ness will be measured not by your individual contributions but by your impact on the people around you

* **Make Hiring Everyone’s Responsibility**
	* as an interviewer, your goal is to optimize for questions with high signal- to-noise ratios
	* simulate the work that their engineers do on a day-to-day basis
	* continuously iterate on improving your interview process
		* Take time with your team to identify which qualities in a potential team- mate you care about the most
		* Periodically meet to discuss how effective the current recruiting and interview processes are
		* Design interview problems with multiple layers of difficulty that you can tailor to the candidate’s ability by adding or removing constraints
		* Control the interview pace to maintain a high signal-to-noise ratio
		* Scan for red flags by rapidly firing short-answer questions to probe a wide surface area
		* Periodically shadow or pair with another team member during interviews
		* Don’t be afraid to use unconventional interview approaches if they help you identify the signals that your team cares about
	(It's an interative process)

* **Design a Good Onboarding Process**
	* A good initial experience influences an engineer’s perception of the engineering culture, shapes her ability to deliver future impact, and directs her learning and activities according to team priorities
	* Goals onboarding process should acheive:
		* Ramp up new engineers as quickly as possible
		* Impart the team’s culture and values
		* Expose new engineers to the breadth of fundamentals needed to succeed
		* Socially integrate new engineers onto the team
	* Different pillars of onboarding program:
		* Codelabs
		* Onboarding talks
		* Mentorship
		* Start-tasks
	(It's an interative process)

* **Share Ownership of Code**
	* There’s a common misconception that being the sole engineer responsible for a project increases your value (very very good point, see reasons at page 207)
	* When you’re the bottleneck (single source of information) for a project, you lose your flexibility to work on other things
	* Strategies to encourage share ownership
		* Avoid one-person team
		* Review each other's code and software designs
		* Rotate different types of tasks and responsibilities across team
		* Keep code readable and code quality high
		* Present tech talks on software decisions and architecture
		* Document your software, either through high-level design or in code-level comments
		* Document the complex workflows or non-obvious workarounds necessary for you to get things done
		* Invest time in teaching and mentoring other team members

* **Build Collective Wisdom through Post-Mortems**
	* Post-Mortem: Discuss and analyze the event, and they write up what happened, how and why it happened, and what they can do to prevent it from happening in the future
	* The purpose is not to assign blame, but to work together to identify better solutions
	* There’s some friction to doing this better. 
		* If your team hasn’t defined a clear goal or metric for a launch, it’s difficult to assess its success. 
		* If your team doesn’t want to publicly declare months of work to be a failure, it’s tempting to close discussions. 
		* Or if your team is overwhelmed with new projects, it’s hard to make time for reflection. 
		As a result, opportunities for building collective wisdom get lost. Lessons might not get learned. or if they do, they are isolated in a few people’s heads. Costly mistakes are repeated. And when people leave, collective wisdom decreases.
	* compiling team lessons is predicated upon honest conversation, and holding an honest conversation about a project can be uncomfortable

* **Build a Great Engineering Culture**
	* Optimize for iteration speed
	* Push relentlessly toward automation
	* build the right software abstractions
	* Focus on high code quality by using code reviews
	* Maintain a respectful work environment
	* Build shared ownership of code
	* Invest in automated testing
	* Allot experimentation time, either through 20% time or hackathons
	* Foster a culture of learning and continuous improvements
	* Hire the best
	(The best engineers enjoy getting things done, and the high-leverage investments we’ve been discussing empower them to get things done faster)